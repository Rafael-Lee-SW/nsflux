<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple RAG Query Interface - Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 20px auto;
        padding: 20px;
        background: #f9f9f9;
        color: #333;
      }
      h1, h2 {
        text-align: center;
      }
      input[type='text'] {
        width: 80%;
        padding: 10px;
        margin-bottom: 20px;
        font-size: 16px;
      }
      button {
        padding: 8px 14px;
        font-size: 14px;
        cursor: pointer;
        margin: 5px;
      }
      .output {
        margin-top: 20px;
        font-size: 16px;
        color: #333;
        text-align: left;
        word-wrap: break-word;
        background: #fff;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .output pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #eee;
        padding: 10px;
        border-radius: 3px;
      }
      /* Test section styling */
      .test-section {
        margin-top: 40px;
        padding: 20px;
        background: #eef;
        border: 1px solid #99c;
        border-radius: 5px;
      }
      .test-section h2 {
        margin-bottom: 20px;
      }
      .test-summary table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
      }
      .test-summary th,
      .test-summary td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: center;
      }
      .test-summary th {
        background: #ddd;
      }
      .test-details .test-item {
        margin-bottom: 20px;
        padding: 10px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .test-details .test-item h4 {
        margin-top: 0;
      }
      .partial-chunk {
        margin: 4px 0;
        padding: 4px;
        background-color: #fafafa;
        border-radius: 3px;
      }
      /* Hidden retrieval data in non-streaming output */
      .hidden-retrieval {
        display: none;
        margin-top: 5px;
        background: #fff9c4;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      /* For the main property table in simultaneous streaming */
      #simul-main-table table {
        border-collapse: collapse;
        width: 100%;
        font-size: 14px;
      }
      #simul-main-table th,
      #simul-main-table td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: center;
      }
      #simul-main-table th {
        background: #ddd;
      }
      /* The partial text containers below the table */
      .partial-text-block {
        margin-top: 10px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
      }
      .partial-text-block h4 {
        margin: 0 0 5px 0;
        font-weight: bold;
      }
      /* Info box style for single streaming times */
      .stream-info-box {
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #bbb;
        border-radius: 4px;
        background: #fff;
        line-height: 1.4em;
        font-size: 14px;
      }
      /* The references are hidden initially */
      #referenceData {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Simple RAG Query Interface</h1>

    <!-- ==========================
         (1) Non-Streaming Query
         ========================== -->
    <input type="text" id="userInput" placeholder="Type your query here..." />
    <button onclick="sendQuery()">Submit</button>
    <div class="output" id="output"></div>

    <!-- ==========================
         (2) Concurrency Test (Non-Streaming POST)
         ========================== -->
    <div class="test-section">
      <h2>Testing the POST requests concurrently (display results as they arrive)</h2>
      <button style="font-size: 16px; padding: 10px 20px;" onclick="testQueries()">Test</button>
      <div class="output" id="testResults"></div>
    </div>

    <!-- ==========================
         (3) Single Streaming Test
         ========================== -->
    <div class="test-section">
      <h2>Streaming Test (Single)</h2>
      <p>Use this to make a single streaming query via SSE.
         The partial tokens accumulate as one text block. Times below are updated as generation proceeds.</p>

      <input type="text" id="streamInput" placeholder="Type your streaming query here..." />
      <button onclick="startStream()">Start Streaming</button>

      <pre id="streamOutput" style="max-height: 250px; overflow-y: auto; white-space: pre-wrap; background: #fafafa;"></pre>

      <div class="stream-info-box" id="streamTiming"></div>

      <button onclick="toggleReferences()">Show References</button>
      <div id="referenceData">
        <h4>Reference Data</h4>
        <ul>
          <li>1. Some reference or doc link</li>
          <li>2. Another doc link</li>
          <li>3. Another reference item</li>
        </ul>
      </div>
    </div>
    <!-- ==========================
         (4) Simultaneous Streaming Test
         ========================== -->
    <div class="test-section">
      <h2>Simultaneous Streaming Test</h2>
      <p>Launch multiple streaming queries at once. Each query has its own SSE connection. We track times and show partial texts separately.</p>
      <button onclick="testStreamingQueries()">Start Simultaneous Streaming</button>
      <!-- The main property table (no partial text) -->
      <div class="output" id="simul-main-table"></div>
      <!-- The partial text blocks area -->
      <div class="output" id="simul-partials"></div>
    </div>
    <!-- ==========================
        (5) Continuous Sync Test
        ========================== -->
    <div class="test-section">
      <h2>Continuous Sync Test</h2>
      <p>Run 10 sequential queries and compute average timings for each version.</p>
      <button onclick="continuousTest('nonstream')">Start Continuous Non-Streaming Test</button>
      <button onclick="continuousTest('stream')">Start Continuous Streaming Test</button>
      <div class="output" id="continuousTestResults"></div>
    </div>

    <script>
      /************************************************************
       * (1) Non-Streaming Query
       ************************************************************/
      function sendQuery() {
        const userInput = document.getElementById('userInput').value;
        const sendTime = new Date();
        const sendTimeStr = formatTime(sendTime);
        const startTimestamp = Date.now();

        fetch('/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ qry_contents: userInput })
        })
          .then((response) => {
            const receiveTime = new Date();
            const receiveTimeStr = formatTime(receiveTime);
            const elapsed = Date.now() - startTimestamp;
            if (!response.ok) {
              return response.json().then((errorData) => { throw errorData; });
            }
            return response.json().then((data) => {
              document.getElementById('output').innerHTML = formatJsonOutput(data, sendTimeStr, receiveTimeStr, elapsed);
            });
          })
          .catch((error) => {
            const receiveTime = new Date();
            const receiveTimeStr = formatTime(receiveTime);
            const elapsed = Date.now() - startTimestamp;
            console.error('Error:', error);
            document.getElementById('output').innerHTML = formatJsonOutput(error, sendTimeStr, receiveTimeStr, elapsed);
          });
      }

      // Helper: Format time => "HH:MM:SS.ms"
      function formatTime(d) {
        if (!d) return '';
        const ms = d.getMilliseconds().toString().padStart(3, '0');
        return d.toLocaleTimeString() + '.' + ms;
      }

      // Build normal JSON results with timing.
      // Only display '답변' (rsp_type "A") immediately; hide '검색데이터' (rsp_type "R") behind a toggle.
      function formatJsonOutput(data, sendTime, receiveTime, elapsed) {
        let formattedOutput = `
          <strong>Send Time:</strong> ${sendTime} <br>
          <strong>Receive Time:</strong> ${receiveTime} <br>
          <strong>Elapsed Time:</strong> ${elapsed} ms <br>
          <hr>
        `;
        if (data.status_code !== undefined) {
          formattedOutput += `
            <strong>Status Code:</strong> ${data.status_code} <br>
            <strong>Result:</strong> ${data.result} <br>
            <strong>Detail:</strong> ${data.detail} <br>
            <strong>Event Time:</strong> ${data.evt_time} <br>
            <strong>Data List:</strong><br>
            <ul>
          `;
          if (data.data_list) {
            let answerHTML = "";
            let retrievalHTML = "";
            data.data_list.forEach((item, idx) => {
              if (item.rsp_type === "A") {
                // Show answer immediately
                answerHTML += `<pre>${JSON.stringify(item, null, 4)}</pre>`;
              } else if (item.rsp_type === "R") {
                // Hide behind "Show Retrieval" button
                const hiddenId = "retrieval_" + idx;
                retrievalHTML += `
                  <div>
                    <button onclick="toggleHiddenDiv('${hiddenId}')">Show Retrieval</button>
                    <div id="${hiddenId}" class="hidden-retrieval">
                      <pre>${JSON.stringify(item, null, 4)}</pre>
                    </div>
                  </div>
                `;
              } else {
                // Otherwise just show it
                answerHTML += `<pre>${JSON.stringify(item, null, 4)}</pre>`;
              }
            });
            if (answerHTML)
              formattedOutput += `<li><strong>Answer(s):</strong> ${answerHTML}</li>`;
            if (retrievalHTML)
              formattedOutput += `<li><strong>Retrieval(s):</strong> ${retrievalHTML}</li>`;
          } else {
            formattedOutput += "<li>No data available</li>";
          }
          formattedOutput += "</ul>";
        } else {
          formattedOutput += "<pre>" + JSON.stringify(data, null, 2) + "</pre>";
        }
        return formattedOutput;
      }

      function toggleHiddenDiv(divId) {
        const div = document.getElementById(divId);
        if (!div) return;
        div.style.display = (div.style.display === "none" || div.style.display === "") ? "block" : "none";
      }

      /************************************************************
       * (2) Concurrency Test (Non-Streaming POST)
       ************************************************************/
      function testQueries() {
        const queries = [
          { id: 'same1-1', text: '신입사원 인사 필수로 알아야 하는 것' },
          { id: 'same1-2', text: '디지털화 근황' },
          { id: 'same1-3', text: 'IOT 컨테이너 사업에 대해서' },
          { id: 'same1-4', text: '주간회의 특징 및 주요 말씀' },
          { id: 'same1-5', text: '해운업계의 경쟁 구도' },
          { id: 'same2-1', text: '신입사원 인사 필수로 알아야 하는 것' },
          { id: 'same2-2', text: '디지털화 근황' },
          { id: 'same2-3', text: 'IOT 컨테이너 사업에 대해서' },
          { id: 'same2-4', text: '주간회의 특징 및 주요 말씀' },
          { id: 'same2-5', text: '해운업계의 경쟁 구도' }
        ];

        document.getElementById('testResults').innerHTML = 'Testing in progress...';

        const results = [];
        let arrivalCounter = 0;

        queries.forEach((query) => {
          const sendTime = new Date();
          const sendTimeStr = formatTime(sendTime);
          const startTimestamp = Date.now();

          fetch('/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qry_contents: query.text })
          })
            .then((response) => {
              const receiveTime = new Date();
              const receiveTimeStr = formatTime(receiveTime);
              const elapsed = Date.now() - startTimestamp;

              return response.json().then((data) => {
                arrivalCounter++;
                results.push({
                  id: query.id,
                  text: query.text,
                  sendTime: sendTimeStr,
                  receiveTime: receiveTimeStr,
                  elapsed: elapsed,
                  status: response.status,
                  data: data,
                  arrival: arrivalCounter
                });
                updateTestResults(results);
              });
            })
            .catch((error) => {
              const receiveTime = new Date();
              const receiveTimeStr = formatTime(receiveTime);
              const elapsed = Date.now() - startTimestamp;
              arrivalCounter++;
              results.push({
                id: query.id,
                text: query.text,
                sendTime: sendTimeStr,
                receiveTime: receiveTimeStr,
                elapsed: elapsed,
                status: 'Error',
                data: error,
                arrival: arrivalCounter
              });
              updateTestResults(results);
            });
        });
      }

      function updateTestResults(results) {
        document.getElementById('testResults').innerHTML = formatTestResults(results);
      }

      function formatTestResults(results) {
        let summaryHTML = `
          <div class="test-summary">
            <h3>Test Summary</h3>
            <table>
              <thead>
                <tr>
                  <th>Arrival Order</th>
                  <th>Test ID</th>
                  <th>Query</th>
                  <th>Send Time</th>
                  <th>Receive Time</th>
                  <th>Elapsed (ms)</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
        `;
        results.forEach((result) => {
          summaryHTML += `
            <tr>
              <td>${result.arrival}</td>
              <td>${result.id}</td>
              <td>${result.text}</td>
              <td>${result.sendTime}</td>
              <td>${result.receiveTime}</td>
              <td>${result.elapsed}</td>
              <td>${result.status}</td>
            </tr>
          `;
        });
        summaryHTML += `
              </tbody>
            </table>
          </div>
        `;

        let detailsHTML = '<div class="test-details"><h3>Individual Test Details</h3>';
        results.forEach((result) => {
          detailsHTML += `
            <div class="test-item">
              <h4>${result.id} - ${result.text}</h4>
              <p><strong>Arrival Order:</strong> ${result.arrival}</p>
              <p><strong>Send Time:</strong> ${result.sendTime}</p>
              <p><strong>Receive Time:</strong> ${result.receiveTime}</p>
              <p><strong>Elapsed Time:</strong> ${result.elapsed} ms</p>
              <p><strong>Status:</strong> ${result.status}</p>
              <p><strong>Response Data (Answer only):</strong></p>
              ${formatJsonOutput(result.data, result.sendTime, result.receiveTime, result.elapsed)}
            </div>
          `;
        });
        detailsHTML += "</div>";

        return summaryHTML + detailsHTML;
      }

      /************************************************************
       * (3) Single Streaming SSE
       ************************************************************/
      let streamEventSource = null;
      let partialAccumulator = "";
      let streamSendTime = null;
      let gotFirstChunkTime = null;
      let doneTime = null;

      function startStream() {
        const userQuery = document.getElementById('streamInput').value.trim();
        if (!userQuery) {
          alert('Please type a streaming query.');
          return;
        }

        partialAccumulator = "";
        gotFirstChunkTime = null;
        doneTime = null;
        const outputEl = document.getElementById('streamOutput');
        outputEl.textContent = "";
        document.getElementById('streamTiming').innerHTML = "";

        streamSendTime = new Date();
        const sendTimeStr = formatTime(streamSendTime);

        document.getElementById('streamTiming').innerHTML = `
          <strong>SSE Send Time:</strong> ${sendTimeStr} <br>
          <strong>Generation Start Time:</strong> (waiting for first chunk...)<br>
          <strong>Generation End Time:</strong> (not finished)<br>
          <strong>Durations:</strong><br>
          &bull; Send→Start: N/A<br>
          &bull; Send→End: N/A<br>
          &bull; Start→End: N/A
        `;

        const sseUrl = '/query_stream?input=' + encodeURIComponent(userQuery);

        if (streamEventSource) {
          streamEventSource.close();
        }

        streamEventSource = new EventSource(sseUrl);

        streamEventSource.onmessage = function (event) {
          const chunk = event.data;
          // Check for done token ignoring whitespace
          const trimmed = chunk.trim();

          // If this is the first real chunk
          if (!gotFirstChunkTime && !trimmed.includes("[[STREAM_DONE]]")) {
            gotFirstChunkTime = new Date();
            updateSingleStreamTiming();
          }

          // If we see the done marker
          if (trimmed.includes("[[STREAM_DONE]]")) {
            doneTime = new Date();
            streamEventSource.close();
            updateSingleStreamTiming();
            return;
          }

          // Otherwise, accumulate text
          partialAccumulator += chunk;
          outputEl.textContent = partialAccumulator;
          outputEl.scrollTop = outputEl.scrollHeight;
        };

        streamEventSource.onerror = function (err) {
          console.error('SSE error:', err);
          doneTime = new Date(); // Set the end time on error
          streamEventSource.close();
          updateSingleStreamTiming();
        };
      }

      function updateSingleStreamTiming() {
        let html = `<strong>SSE Send Time:</strong> ${formatTime(streamSendTime)}<br>`;
        html += gotFirstChunkTime
          ? `<strong>Generation Start Time:</strong> ${formatTime(gotFirstChunkTime)}<br>`
          : `<strong>Generation Start Time:</strong> (waiting...)<br>`;
        html += doneTime
          ? `<strong>Generation End Time:</strong> ${formatTime(doneTime)}<br>`
          : `<strong>Generation End Time:</strong> (not finished)<br>`;

        let sendToStart = '(N/A)', sendToEnd = '(N/A)', startToEnd = '(N/A)';
        if (gotFirstChunkTime) {
          sendToStart = (gotFirstChunkTime - streamSendTime) + ' ms';
        }
        if (doneTime) {
          sendToEnd = (doneTime - streamSendTime) + ' ms';
        }
        if (gotFirstChunkTime && doneTime) {
          startToEnd = (doneTime - gotFirstChunkTime) + ' ms';
        }

        html += `<strong>Durations:</strong><br>
                 &bull; Send→Start: ${sendToStart}<br>
                 &bull; Send→End: ${sendToEnd}<br>
                 &bull; Start→End: ${startToEnd}`;
        document.getElementById('streamTiming').innerHTML = html;
      }

      function toggleReferences() {
        const refDiv = document.getElementById('referenceData');
        if (refDiv.style.display === 'none' || refDiv.style.display === '') {
          refDiv.style.display = 'block';
        } else {
          refDiv.style.display = 'none';
        }
      }

      /************************************************************
       * (4) Simultaneous Streaming SSE
       ************************************************************/
      let simulResults = []; // { id, query, partialText, startTime, firstChunkTime, endTime }

      function testStreamingQueries() {
        const sseQueries = [
          { id: 'SSE-1', text: '디지털화 근황' },
          { id: 'SSE-2', text: 'IOT 컨테이너 사업에 대해서' },
          { id: 'SSE-3', text: '주간회의 특징' }
        ];

        document.getElementById('simul-main-table').innerHTML = '';
        document.getElementById('simul-partials').innerHTML = '';
        simulResults = [];

        sseQueries.forEach((q) => {
          const now = new Date();
          const resultObj = {
            id: q.id,
            query: q.text,
            partialText: '',
            startTime: now,
            firstChunkTime: null,
            endTime: null
          };
          simulResults.push(resultObj);

          const url = '/query_stream?input=' + encodeURIComponent(q.text);
          const es = new EventSource(url);

          let gotFirstChunk = false;
          es.onmessage = (evt) => {
            const trimmed = evt.data.trim();
            if (!gotFirstChunk && !trimmed.includes("[[STREAM_DONE]]")) {
              gotFirstChunk = true;
              resultObj.firstChunkTime = new Date();
            }
            if (trimmed.includes("[[STREAM_DONE]]")) {
              resultObj.endTime = new Date();
              es.close();
            } else {
              resultObj.partialText += evt.data;
            }
            updateSimulProps(simulResults);
            updateSimulPartials(simulResults);
          };

          es.onerror = (err) => {
            console.error('SSE error on ' + q.id, err);
            resultObj.endTime = new Date();
            es.close();
            updateSimulProps(simulResults);
            updateSimulPartials(simulResults);
          };
        });
      }

      function updateSimulProps(results) {
        let html = `
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Query</th>
                <th>Send Time</th>
                <th>Start Time</th>
                <th>End Time</th>
                <th>Durations (ms)</th>
              </tr>
            </thead>
            <tbody>
        `;

        results.forEach((r) => {
          const firstChunkStr = r.firstChunkTime ? formatTime(r.firstChunkTime) : '(not yet)';
          const endStr = r.endTime ? formatTime(r.endTime) : '(not finished)';

          let sendToStart = '', sendToEnd = '', startToEnd = '';
          if (r.firstChunkTime) {
            sendToStart = r.firstChunkTime - r.startTime + '';
          }
          if (r.endTime) {
            sendToEnd = r.endTime - r.startTime + '';
          }
          if (r.firstChunkTime && r.endTime) {
            startToEnd = r.endTime - r.firstChunkTime + '';
          }

          html += `
            <tr>
              <td>${r.id}</td>
              <td>${r.query}</td>
              <td>${formatTime(r.startTime)}</td>
              <td>${firstChunkStr}</td>
              <td>${endStr}</td>
              <td>
                Send→Start: ${sendToStart}<br>
                Send→End: ${sendToEnd}<br>
                Start→End: ${startToEnd}
              </td>
            </tr>
          `;
        });
        html += `</tbody></table>`;
        document.getElementById('simul-main-table').innerHTML = html;
      }

      function updateSimulPartials(results) {
        let html = '<h3>Partial Text Blocks</h3>';
        results.forEach((r) => {
          html += `
            <div class="partial-text-block">
              <h4>${r.id} - Partial Text</h4>
              <pre>${r.partialText}</pre>
            </div>
          `;
        });
        document.getElementById('simul-partials').innerHTML = html;
      }

      // Function to run continuous tests
      async function continuousTest(mode) {
        const results = [];
        const totalRuns = 10;
        document.getElementById('continuousTestResults').innerHTML = "Running test...<br>";
        
        for (let i = 0; i < totalRuns; i++) {
          if (mode === 'nonstream') {
            const res = await runNonStreamingQuery(i + 1);
            results.push(res);
          } else if (mode === 'stream') {
            const res = await runStreamingQuery(i + 1);
            results.push(res);
          }
        }
        
        // Compute average durations
        let totalDuration = results.reduce((sum, item) => sum + item.duration, 0);
        let avgDuration = (totalDuration / totalRuns).toFixed(2);
        
        let html = `<h3>${mode === 'nonstream' ? 'Non-Streaming' : 'Streaming'} Test Results</h3>`;
        html += "<ul>";
        results.forEach((r, idx) => {
          html += `<li>Run ${idx + 1}: Start: ${r.startTime}, End: ${r.endTime}, Duration: ${r.duration} ms</li>`;
        });
        html += `</ul><strong>Average Duration: ${avgDuration} ms</strong>`;
        document.getElementById('continuousTestResults').innerHTML = html;
      }

      // For non-streaming test: sends a normal POST request and records start/end times.
      async function runNonStreamingQuery(runNumber) {
        const queryText = "디지털 전략"; // or any test query
        const sendTime = new Date();
        const startTimestamp = Date.now();
        
        try {
          const response = await fetch('/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qry_contents: queryText })
          });
          await response.json(); // wait for complete JSON result
        } catch (error) {
          console.error("Error in non-streaming query", error);
        }
        
        const endTime = new Date();
        const duration = Date.now() - startTimestamp;
        return {
          run: runNumber,
          startTime: formatTime(sendTime),
          endTime: formatTime(endTime),
          duration: duration
        };
      }

      // For streaming test: returns a promise that resolves when streaming is finished.
      function runStreamingQuery(runNumber) {
        return new Promise((resolve, reject) => {
          const queryText = "디지털 전략"; // test query
          const sendTime = new Date();
          const startTimestamp = Date.now();
          let firstChunkTime = null;
          
          // Create a temporary EventSource (similar to startStream() but self-contained)
          const sseUrl = '/query_stream?input=' + encodeURIComponent(queryText);
          const es = new EventSource(sseUrl);
          es.onmessage = function (event) {
            const chunk = event.data;
            // If final result message, ignore for timing purposes
            if (chunk.startsWith("[[FINAL_RESULT]]")) return;
            
            if (!firstChunkTime && !chunk.includes("[[STREAM_DONE]]")) {
              firstChunkTime = new Date();
            }
            if (chunk.includes("[[STREAM_DONE]]")) {
              const endTime = new Date();
              const duration = Date.now() - startTimestamp;
              es.close();
              resolve({
                run: runNumber,
                startTime: formatTime(sendTime),
                endTime: formatTime(endTime),
                duration: duration
              });
            }
          };
          es.onerror = function (err) {
            const endTime = new Date();
            const duration = Date.now() - startTimestamp;
            es.close();
            resolve({
              run: runNumber,
              startTime: formatTime(sendTime),
              endTime: formatTime(endTime),
              duration: duration
            });
          };
        });
      }
    </script>
  </body>
</html>
