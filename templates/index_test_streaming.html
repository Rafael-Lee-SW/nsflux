<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple RAG Query Interface - Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 20px auto;
        padding: 20px;
        background: #f9f9f9;
        color: #333;
      }
      h1, h2 {
        text-align: center;
      }
      input[type='text'] {
        width: 80%;
        padding: 10px;
        margin-bottom: 20px;
        font-size: 16px;
      }
      button {
        padding: 8px 14px;
        font-size: 14px;
        cursor: pointer;
        margin: 5px;
      }
      .output {
        margin-top: 20px;
        font-size: 16px;
        color: #333;
        text-align: left;
        word-wrap: break-word;
        background: #fff;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .output pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #eee;
        padding: 10px;
        border-radius: 3px;
      }
      /* Test section styling */
      .test-section {
        margin-top: 40px;
        padding: 20px;
        background: #eef;
        border: 1px solid #99c;
        border-radius: 5px;
      }
      .test-section h2 {
        margin-bottom: 20px;
      }
      .test-summary table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
      }
      .test-summary th,
      .test-summary td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: center;
      }
      .test-summary th {
        background: #ddd;
      }
      .test-details .test-item {
        margin-bottom: 20px;
        padding: 10px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .test-details .test-item h4 {
        margin-top: 0;
      }
      .partial-chunk {
        margin: 4px 0;
        padding: 4px;
        background-color: #fafafa;
        border-radius: 3px;
      }
      /* Hidden retrieval data in non-streaming output */
      .hidden-retrieval {
        display: none;
        margin-top: 5px;
        background: #fff9c4;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      /* For the main property table in simultaneous streaming */
      #simul-main-table table {
        border-collapse: collapse;
        width: 100%;
        font-size: 14px;
      }
      #simul-main-table th,
      #simul-main-table td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: center;
      }
      #simul-main-table th {
        background: #ddd;
      }
      /* The partial text containers below the table */
      .partial-text-block {
        margin-top: 10px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
      }
      .partial-text-block h4 {
        margin: 0 0 5px 0;
        font-weight: bold;
      }
      /* Info box style for single streaming times */
      .stream-info-box {
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #bbb;
        border-radius: 4px;
        background: #fff;
        line-height: 1.4em;
        font-size: 14px;
      }
      /* The references are hidden initially */
      #referenceData {
        display: none;
      }
      /* Test set selector styling */
      .test-set-selector {
        margin-bottom: 20px;
        text-align: center;
      }
      .test-set-selector label {
        font-weight: bold;
        margin-right: 10px;
        cursor: pointer;
      }
      .test-set-selector select {
        padding: 5px;
        font-size: 14px;
      }
      /* Progress indicator styling */
      .progress-indicator {
        font-weight: bold;
        margin-bottom: 10px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>Simple RAG Query Interface</h1>
    
    <!-- Test Set Selector -->
    <div class="test-set-selector">
      <label for="testSetSelect" title="옵션별 설명:
• 20 Multi SET1: SET1의 20개 질문
• 20 Multi SET2: SET2의 20개 질문
• 20 Multi SET3: SET3의 20개 질문
• Same Question 100 Times: 동일한 질문 ('디지털 전략') 100회 반복
• 5 Questions Circulate 20 Times: 5개의 다른 질문을 20회씩 반복 (총 100개)
• 100 Mixed: 100개의 다양한 혼합 질문 (Mix Test Set)">Test Set:</label>
      <select id="testSetSelect">
        <option value="set1" title="20개의 다른 질문 SET1" selected>20개의 다른 질문 세트 1번</option>
        <option value="set2" title="20개의 다른 질문 SET2">20개의 다른 질문 세트 2번</option>
        <option value="set3" title="20개의 다른 질문 SET3">20개의 다른 질문 세트 3번</option>
        <option value="same100" title="동일한 질문 '디지털 전략'을 100회 반복">같은 질문('디지털 전략') 100개</option>
        <option value="circulate5x20" title="5개의 다른 질문을 20회씩 반복 (총 100개)">5개의 다른 질문 세트 20번 반복</option>
        <option value="mixed100" title="100개의 다양한 혼합 질문 (Mix Test Set)">100개의 다른 질문</option>
      </select>
    </div>
    
    <!-- ==========================
         (1) Non-Streaming Query
         ========================== -->
    <input type="text" id="userInput" placeholder="Type your query here..." />
    <button onclick="sendQuery()">단일 전송(스트리밍 X)</button>
    <div class="output" id="output"></div>

    <!-- ==========================
         (2) Concurrency Test (Non-Streaming POST) - 50 queries
         ========================== -->
    <div class="test-section">
      <h2>한 번에 질문 여러개 전송하기 테스트</h2>
      <h5>Testing the POST requests concurrently (display results as they arrive)</h5>
      <div id="progressIndicator" class="progress-indicator"></div>
      <button style="font-size: 16px; padding: 10px 20px;" onclick="testQueries()">Test</button>
      <div class="output" id="testResults"></div>
    </div>

    <!-- ==========================
         (3) Single Streaming Test (POST-based)
         ========================== -->
    <div class="test-section">
      <h2>스트리밍 테스트(단일 - POST)</h2>
      <h5>Streaming Test (Single via POST)</h5>
      <p>
        This test uses a POST-based fetch to stream the response.
        The server sends SSE-style chunks and we process them manually.
      </p>
      <input type="text" id="streamInput" placeholder="Type your streaming query here..." />
      <button onclick="startStreamPOST()">Start Streaming (POST)</button>
      <pre id="streamOutput" style="max-height: 250px; overflow-y: auto; white-space: pre-wrap; background: #fafafa;"></pre>
      <div class="stream-info-box" id="streamTiming"></div>
      <button onclick="toggleReferences()">Show References</button>
      <div id="referenceData">
        <h4>Reference Data</h4>
        <ul>
          <li>1. Some reference or doc link</li>
          <li>2. Another doc link</li>
          <li>3. Another reference item</li>
        </ul>
      </div>
    </div>

    <!-- ==========================
         (4) Simultaneous Streaming Test (GET-based)
         ========================== -->
    <div class="test-section">
      <h2>스트리밍 테스트(동시 3개, 테스트셋)</h2>
      <h5>Simultaneous Streaming Test (GET-based SSE)</h5>
      <p>
        Launch multiple streaming queries at once using GET-based SSE.
      </p>
      <button onclick="testStreamingQueries()">Start Simultaneous Streaming</button>
      <button onclick="testStreamingQueriesMulti()">테스트 셋으로 테스트</button>
      <div class="output" id="simul-main-table"></div>
      <div class="output" id="simul-partials"></div>
    </div>

    <!-- ==========================
         (5) Continuous Sync Test
         ========================== -->
    <div class="test-section">
      <h2>연속 질문 테스트(단일 평균 시간 테스트)</h2>
      <h5>Continuous Sync Test</h5>
      <p>
        Run 100 sequential queries (from same1-1 to same20-5) based on the selected test set.
        Choose either non-streaming or streaming approach, and compute average timings in ms.
      </p>
      <div id="continuousProgress" class="progress-indicator"></div>
      <button onclick="continuousTest('nonstream')">Start Continuous Non-Streaming Test (100 queries)</button>
      <button onclick="continuousTest('stream')">Start Continuous Streaming Test (100 queries)</button>
      <div class="output" id="continuousTestResults"></div>
    </div>

    <script>
      /************************************************************
       * (1) Non-Streaming Query
       ************************************************************/
      function sendQuery() {
        const userInput = document.getElementById('userInput').value;
        const sendTime = new Date();
        const sendTimeStr = formatTime(sendTime);
        const startTimestamp = Date.now();

        fetch('/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ qry_contents: userInput })
        })
          .then((response) => {
            const receiveTime = new Date();
            const receiveTimeStr = formatTime(receiveTime);
            const elapsed = Date.now() - startTimestamp;
            if (!response.ok) {
              return response.json().then((errorData) => { throw errorData; });
            }
            return response.json().then((data) => {
              document.getElementById('output').innerHTML = formatJsonOutput(data, sendTimeStr, receiveTimeStr, elapsed);
            });
          })
          .catch((error) => {
            const receiveTime = new Date();
            const receiveTimeStr = formatTime(receiveTime);
            const elapsed = Date.now() - startTimestamp;
            console.error('Error:', error);
            document.getElementById('output').innerHTML = formatJsonOutput(error, sendTimeStr, receiveTimeStr, elapsed);
          });
      }

      // Helper: Format time => "HH:MM:SS.ms"
      function formatTime(d) {
        if (!d) return '';
        const ms = d.getMilliseconds().toString().padStart(3, '0');
        return d.toLocaleTimeString() + '.' + ms;
      }

      // Build JSON output
      function formatJsonOutput(data, sendTime, receiveTime, elapsed, uniquePrefix = '') {
        let formattedOutput = `
          <strong>Send Time:</strong> ${sendTime} <br>
          <strong>Receive Time:</strong> ${receiveTime} <br>
          <strong>Elapsed Time:</strong> ${elapsed} ms <br>
          <hr>
        `;
        if (data.status_code !== undefined) {
          formattedOutput += `
            <strong>Status Code:</strong> ${data.status_code} <br>
            <strong>Result:</strong> ${data.result} <br>
            <strong>Detail:</strong> ${data.detail} <br>
            <strong>Event Time:</strong> ${data.evt_time} <br>
            <strong>Data List:</strong><br>
            <ul>
          `;
          if (data.data_list) {
            let answerHTML = "";
            let retrievalHTML = "";
            data.data_list.forEach((item, idx) => {
              if (item.rsp_type === "A") {
                answerHTML += `<pre>${JSON.stringify(item, null, 4)}</pre>`;
              } else if (item.rsp_type === "R") {
                const hiddenId = `retrieval_${uniquePrefix}_${idx}`;
                retrievalHTML += `
                  <div>
                    <button onclick="toggleHiddenDiv('${hiddenId}')">Show Retrieval</button>
                    <div id="${hiddenId}" class="hidden-retrieval" style="display:none;">
                      <pre>${JSON.stringify(item, null, 4)}</pre>
                    </div>
                  </div>
                `;
              } else {
                answerHTML += `<pre>${JSON.stringify(item, null, 4)}</pre>`;
              }
            });
            if (answerHTML)
              formattedOutput += `<li><strong>Answer(s):</strong> ${answerHTML}</li>`;
            if (retrievalHTML)
              formattedOutput += `<li><strong>Retrieval(s):</strong> ${retrievalHTML}</li>`;
          } else {
            formattedOutput += "<li>No data available</li>";
          }
          formattedOutput += "</ul>";
        } else {
          formattedOutput += "<pre>" + JSON.stringify(data, null, 2) + "</pre>";
        }
        return formattedOutput;
      }

      function toggleHiddenDiv(divId) {
        const div = document.getElementById(divId);
        if (!div) return;
        div.style.display = (div.style.display === "none" || div.style.display === "") ? "block" : "none";
      }

      /************************************************************
       * (2) Concurrency Test (Non-Streaming POST) - 50 queries
       ************************************************************/
      function testQueries() {
        const queries = buildTestQueries();
        document.getElementById('testResults').innerHTML = 'Testing in progress...';
        const totalQueries = queries.length;
        let arrivalCounter = 0;
        updateProgressIndicator('progressIndicator', arrivalCounter, totalQueries);
        const results = [];

        queries.forEach((query) => {
          const sendTime = new Date();
          const sendTimeStr = formatTime(sendTime);
          const startTimestamp = Date.now();

          fetch('/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qry_contents: query.text })
          })
            .then((response) => {
              const receiveTime = new Date();
              const receiveTimeStr = formatTime(receiveTime);
              const elapsed = Date.now() - startTimestamp;
              return response.json().then((data) => {
                arrivalCounter++;
                results.push({
                  id: query.id,
                  text: query.text,
                  sendTime: sendTimeStr,
                  receiveTime: receiveTimeStr,
                  elapsed: elapsed,
                  status: response.status,
                  data: data,
                  arrival: arrivalCounter
                });
                updateTestResults(results);
                updateProgressIndicator('progressIndicator', arrivalCounter, totalQueries);
              });
            })
            .catch((error) => {
              const receiveTime = new Date();
              const receiveTimeStr = formatTime(receiveTime);
              const elapsed = Date.now() - startTimestamp;
              arrivalCounter++;
              results.push({
                id: query.id,
                text: query.text,
                sendTime: sendTimeStr,
                receiveTime: receiveTimeStr,
                elapsed: elapsed,
                status: 'Error',
                data: error,
                arrival: arrivalCounter
              });
              updateTestResults(results);
              updateProgressIndicator('progressIndicator', arrivalCounter, totalQueries);
            });
        });
      }

      function updateProgressIndicator(elementId, current, total) {
        const elem = document.getElementById(elementId);
        if (elem) {
          elem.innerText = `완료: ${current} / ${total} queries`;
        }
      }

      function updateTestResults(results) {
        document.getElementById('testResults').innerHTML = formatTestResults(results);
      }

      function formatTestResults(results) {
        let summaryHTML = `
          <div class="test-summary">
            <h3>Test Summary</h3>
            <table>
              <thead>
                <tr>
                  <th>Arrival Order</th>
                  <th>Test ID</th>
                  <th>Query</th>
                  <th>Send Time</th>
                  <th>Receive Time</th>
                  <th>Elapsed (ms)</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody>
        `;
        results.forEach((result) => {
          summaryHTML += `
            <tr>
              <td>${result.arrival}</td>
              <td>${result.id}</td>
              <td>${result.text}</td>
              <td>${result.sendTime}</td>
              <td>${result.receiveTime}</td>
              <td>${result.elapsed}</td>
              <td>${result.status}</td>
            </tr>
          `;
        });
        summaryHTML += `
              </tbody>
            </table>
          </div>
        `;

        let detailsHTML = '<div class="test-details"><h3>Individual Test Details</h3>';
        results.forEach((result) => {
          const safeResultOutput = formatJsonOutput(
            result.data,
            result.sendTime,
            result.receiveTime,
            result.elapsed,
            result.id
          );
          detailsHTML += `
            <div class="test-item">
              <h4>${result.id} - ${result.text}</h4>
              <p><strong>Arrival Order:</strong> ${result.arrival}</p>
              <p><strong>Send Time:</strong> ${result.sendTime}</p>
              <p><strong>Receive Time:</strong> ${result.receiveTime}</p>
              <p><strong>Elapsed Time:</strong> ${result.elapsed} ms</p>
              <p><strong>Status:</strong> ${result.status}</p>
              <p><strong>Response Data (Answer only):</strong></p>
              ${safeResultOutput}
            </div>
          `;
        });
        detailsHTML += "</div>";
        return summaryHTML + detailsHTML;
      }

      /************************************************************
       * (3) Single Streaming Test (POST-based streaming)
       ************************************************************/
      let postStreamPartial = "";
      let postStreamStartTime, postStreamFirstChunkTime, postStreamEndTime;

      async function startStreamPOST() {
        const userQuery = document.getElementById('streamInput').value.trim();
        if (!userQuery) {
          alert('Please type a streaming query.');
          return;
        }
        // Reset variables
        postStreamPartial = "";
        postStreamFirstChunkTime = null;
        postStreamEndTime = null;
        document.getElementById('streamOutput').textContent = "";
        document.getElementById('streamTiming').innerHTML = "";

        postStreamStartTime = performance.now();

        try {
          const response = await fetch('/query_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: userQuery })
          });
          if (!response.ok) {
            const errTxt = await response.text();
            throw new Error('Response not OK: ' + response.status + " " + errTxt);
          }
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              postStreamEndTime = performance.now();
              updatePostStreamTiming();
              break;
            }
            const chunk = decoder.decode(value, { stream: true });
            processPostSseChunk(chunk);
            document.getElementById('streamOutput').textContent = postStreamPartial;
          }
        } catch (err) {
          console.error('POST-based streaming error:', err);
          postStreamEndTime = performance.now();
          updatePostStreamTiming();
        }
      }

      function processPostSseChunk(chunk) {
        // SSE chunks in POST are expected as: "data: <text>\n\n"
        const lines = chunk.split("\n");
        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          if (line.startsWith("data:")) {
            const sseData = line.slice(5).trim();
            if (!postStreamFirstChunkTime && !sseData.includes("[[STREAM_DONE]]")) {
              postStreamFirstChunkTime = performance.now();
              updatePostStreamTiming();
            }
            if (sseData === "[[STREAM_DONE]]") {
              postStreamEndTime = performance.now();
              updatePostStreamTiming();
              return;
            }
            postStreamPartial += sseData;
          }
        }
        updatePostStreamTiming();
      }

      function updatePostStreamTiming() {
        let msg = "";
        if (postStreamStartTime) {
          msg += `Started: ${postStreamStartTime.toFixed(1)} ms\n`;
        }
        if (postStreamFirstChunkTime) {
          msg += `First chunk: ${postStreamFirstChunkTime.toFixed(1)} ms (delta: ${(postStreamFirstChunkTime - postStreamStartTime).toFixed(1)} ms)\n`;
        } else {
          msg += "First chunk: not yet\n";
        }
        if (postStreamEndTime) {
          msg += `End: ${postStreamEndTime.toFixed(1)} ms (delta: ${(postStreamEndTime - postStreamStartTime).toFixed(1)} ms)\n`;
          if (postStreamFirstChunkTime) {
            msg += `Chunk→End: ${(postStreamEndTime - postStreamFirstChunkTime).toFixed(1)} ms\n`;
          }
        } else {
          msg += "End: not yet\n";
        }
        document.getElementById('streamTiming').innerHTML = msg;
      }

      /************************************************************
       * (4) Simultaneous Streaming Test (GET-based SSE)
       ************************************************************/
      // Helper: Stream a single query via POST
      async function startStreamForQuery(queryObj) {
        const sendTime = performance.now();
        let firstChunkTime = null;
        try {
          const response = await fetch('/query_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: queryObj.text })
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let partialText = "";
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            if (!firstChunkTime && chunk.trim() !== "") {
              firstChunkTime = performance.now();
            }
            partialText += chunk;
          }
          const endTime = performance.now();
          return {
            id: queryObj.id,
            query: queryObj.text,
            startTime: sendTime,
            endTime: endTime,
            duration: endTime - sendTime,
            partialText: partialText
          };
        } catch (err) {
          console.error("Streaming error for", queryObj.id, err);
          const endTime = performance.now();
          return {
            id: queryObj.id,
            query: queryObj.text,
            startTime: sendTime,
            endTime: endTime,
            duration: endTime - sendTime,
            partialText: ""
          };
        }
      }

      /************************************************************
       * (4) Simultaneous Streaming Test (POST-based streaming)
       * We replace GET-based EventSource with POST-based streaming
       ************************************************************/
      async function startStreamForQuery(queryObj) {
        const sendTime = performance.now();
        try {
          const response = await fetch('/query_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: queryObj.text })
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let partialText = "";
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            partialText += decoder.decode(value, { stream: true });
          }
          const endTime = performance.now();
          return {
            id: queryObj.id,
            query: queryObj.text,
            startTime: sendTime,
            endTime: endTime,
            duration: endTime - sendTime,
            partialText: partialText
          };
        } catch (err) {
          console.error("Streaming error for", queryObj.id, err);
          const endTime = performance.now();
          return {
            id: queryObj.id,
            query: queryObj.text,
            startTime: sendTime,
            endTime: endTime,
            duration: endTime - sendTime,
            partialText: ""
          };
        }
      }
      async function startSimulStream(queryObj, streamNumber) {
        const containerId = `stream-${streamNumber}`;
        const container = document.getElementById(containerId);
        container.innerHTML = `<h4>${queryObj.id} - ${queryObj.text}</h4><div class="partial-content"></div>`;
        
        try {
          const response = await fetch('/query_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: queryObj.text })
          });
    
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let partial = '';
          
          activeStreams.set(queryObj.id, { reader, decoder });
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            const chunk = decoder.decode(value, { stream: true });
            partial += chunk;
            
            // Process SSE chunks
            const lines = partial.split('\n');
            partial = lines.pop(); // Store incomplete line
            
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const content = line.replace('data:', '').trim();
                if (content === '[[STREAM_DONE]]') break;
                
                const contentDiv = container.querySelector('.partial-content');
                contentDiv.textContent += content;
              }
            }
          }
        } catch (err) {
          console.error(`Stream error for ${queryObj.id}:`, err);
          container.innerHTML += `<p style="color:red">Error: ${err.message}</p>`;
        } finally {
          activeStreams.delete(queryObj.id);
        }
      }
      // Update the table to include first chunk time
      function updateSimulProps(results) {
        let html = `<table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Query</th>
                <th>Send Time</th>
                <th>First Chunk Time</th>
                <th>End Time</th>
                <th>Duration (ms)</th>
              </tr>
            </thead>
            <tbody>`;
        results.forEach(r => {
          const sendStr = r.sendTime.toFixed(1);
          const firstStr = r.firstChunkTime ? r.firstChunkTime.toFixed(1) : '(n/a)';
          const endStr = r.endTime.toFixed(1);
          const durationStr = r.duration.toFixed(1);
          html += `<tr>
              <td>${r.id}</td>
              <td>${r.query}</td>
              <td>${sendStr}</td>
              <td>${firstStr}</td>
              <td>${endStr}</td>
              <td>${durationStr}</td>
            </tr>`;
        });
        html += `</tbody></table>`;
        document.getElementById('simul-main-table').innerHTML = html;
      }
      function updateSimulPartials(results) {
        let html = '<h3>Partial Text Blocks</h3>';
        results.forEach(r => {
          html += `<div class="partial-text-block">
                      <h4>${r.id} - Partial Text</h4>
                      <pre>${r.partialText}</pre>
                    </div>`;
        });
        document.getElementById('simul-partials').innerHTML = html;
      }
      /************************************************************
      * (4.1) Simultaneous Three Streaming Test (POST-based streaming)
      ************************************************************/
      const activeStreams = new Map();
      async function testStreamingQueries() {
        // Use a fixed set of 3 queries
        const sseQueries = [
          { id: 'SSE-1', text: '디지털화 근황' },
          { id: 'SSE-2', text: 'IOT 컨테이너 사업에 대해서' },
          { id: 'SSE-3', text: '주간회의 특징' }
        ];
        const simulResults = await Promise.all(sseQueries.map(q => startStreamForQuery(q)));
        updateSimulProps(simulResults);
        updateSimulPartials(simulResults);
      }

      /************************************************************
      * (4.2) Simultaneous Multi Streaming Test (POST-based streaming)
      ************************************************************/
      async function testStreamingQueriesMulti() {
        const testQueries = buildTestQueries();
        // Create a container for each query result
        const simulResults = await Promise.all(testQueries.map(q => startStreamForQuery(q)));
        updateSimulProps(simulResults);
        updateSimulPartials(simulResults);
      }

      /************************************************************
       * (5) Continuous Sync Test
       ************************************************************/
      async function continuousTest(mode) {
        const queries = buildTestQueries();
        const results = [];
        const total = queries.length;
        document.getElementById('continuousTestResults').innerHTML = `Running ${mode} test...<br>`;
        updateProgressIndicator('continuousProgress', 0, total);
    
        for (let i = 0; i < queries.length; i++) {
          if (mode === 'nonstream') {
            const r = await runNonStreamingQuery(queries[i]);
            results.push(r);
          } else {
            const r = await runStreamingQuery(queries[i]);
            results.push(r);
          }
          updateProgressIndicator('continuousProgress', i + 1, total);
        }
    
        let sum = 0;
        results.forEach(r => sum += r.duration);
        const avg = (sum / results.length).toFixed(2);
    
        let html = `<h3>Continuous ${mode === 'nonstream' ? 'Non-Streaming' : 'Streaming'} Test (100 queries) Results</h3>`;
        html += `<p>Average Duration: <strong>${avg} ms</strong></p>`;
        html += "<ul>";
        results.forEach((r, idx) => {
          html += `<li><strong>${r.id}</strong> [${r.query}] - Start: ${r.startTime}, End: ${r.endTime}, Duration: ${r.duration} ms</li>`;
        });
        html += "</ul>";
        document.getElementById('continuousTestResults').innerHTML = html;
      }

      async function runNonStreamingQuery(qObj) {
        const sendTime = new Date();
        const startTs = Date.now();
        try {
          const resp = await fetch('/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qry_contents: qObj.text })
          });
          await resp.json();
        } catch (e) {
          console.error("Non-stream error:", e);
        }
        const endTime = new Date();
        const duration = Date.now() - startTs;
        return {
          id: qObj.id,
          query: qObj.text,
          startTime: formatTime(sendTime),
          endTime: formatTime(endTime),
          duration: duration
        };
      }
    
      function runStreamingQuery(qObj) {
        return new Promise((resolve, reject) => {
          const sendTime = new Date();
          const startTs = Date.now();
          const sseUrl = '/query_stream?input=' + encodeURIComponent(qObj.text);
          const es = new EventSource(sseUrl);
          es.onmessage = (evt) => {
            const trimmed = evt.data.trim();
            if (trimmed.includes("[[STREAM_DONE]]")) {
              es.close();
              const endTime = new Date();
              const duration = Date.now() - startTs;
              resolve({
                id: qObj.id,
                query: qObj.text,
                startTime: formatTime(sendTime),
                endTime: formatTime(endTime),
                duration: duration
              });
            }
          };
          es.onerror = (err) => {
            console.error("Stream error on", qObj.id, err);
            es.close();
            const endTime = new Date();
            const duration = Date.now() - startTs;
            resolve({
              id: qObj.id,
              query: qObj.text,
              startTime: formatTime(sendTime),
              endTime: formatTime(endTime),
              duration: duration
            });
          };
        });
      }
    
      function buildTestQueries() {
        const testSet = document.getElementById('testSetSelect').value;
        let queries = [];
        if (testSet === 'set1') {
          const mixed20Queries1 = [
            { id: "ask1", text: "남성해운의 중국 시장 동향" },
            { id: "ask2", text: "남성해운의 일본 시장 영업 전략" },
            { id: "ask3", text: "남성해운의 동남아 시장 발전 가능성" },
            { id: "ask4", text: "남성해운의 중국 시장 동향" },
            { id: "ask5", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "ask6", text: "디지털화 근황" },
            { id: "ask7", text: "IOT 컨테이너 사업에 대해서" },
            { id: "ask8", text: "남성해운 운임 동향" },
            { id: "ask9", text: "주간회의 특징 및 주요 말씀" },
            { id: "ask10", text: "최근 해운업계 동향" },
            { id: "ask11", text: "디지털화 근황" },
            { id: "ask12", text: "IOT 컨테이너 사업에 대해서" },
            { id: "ask13", text: "남성해운 운임 동향" },
            { id: "ask14", text: "주간회의 특징 및 주요 말씀" },
            { id: "ask15", text: "최근 해운업계 동향" },
            { id: "ask16", text: "디지털화 근황" },
            { id: "ask17", text: "IOT 컨테이너 사업에 대해서" },
            { id: "ask18", text: "남성해운 운임 동향" },
            { id: "ask19", text: "주간회의 특징 및 주요 말씀" },
            { id: "ask20", text: "최근 해운업계 동향" }
          ];
          queries = mixed20Queries1;
        } else if (testSet === 'set2') {
          const mixed20Queries2 = [
            { id: "ask1", text: "타운사의 전략" },
            { id: "ask2", text: "남성해운과 타운사의 차별점" },
            { id: "ask3", text: "남성해운의 수익 구조" },
            { id: "ask4", text: "해운사의 특징과 남성해운이 가진 고유의 특징" },
            { id: "ask5", text: "지난해 매출과 앞으로의 전망" },
            { id: "ask6", text: "남성해운의 AI 추진 과제 현황" },
            { id: "ask7", text: "동영해운과 남성해운의 공통점과 차이점" },
            { id: "ask8", text: "남성해운의 새로운 전략과 먹거리" },
            { id: "ask9", text: "신입사원 채용 계획 및 교육 일정" },
            { id: "ask10", text: "해운업계의 큰 흐름과 현재 남성해운의 판단" },
            { id: "ask11", text: "디지털화 근황" },
            { id: "ask12", text: "IOT 컨테이너 사업에 대해서" },
            { id: "ask13", text: "남성해운 운임 동향" },
            { id: "ask14", text: "주간회의 특징 및 주요 말씀" },
            { id: "ask15", text: "최근 해운업계 동향" },
            { id: "ask16", text: "디지털화 근황" },
            { id: "ask17", text: "IOT 컨테이너 사업에 대해서" },
            { id: "ask18", text: "남성해운 운임 동향" },
            { id: "ask19", text: "주간회의 특징 및 주요 말씀" },
            { id: "ask20", text: "최근 해운업계 동향" }
          ];
          queries = mixed20Queries2;
        } else if (testSet === 'set3') {
          const mixed20Queries3 = [
            { id: "same1-1", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "same1-2", text: "디지털화 근황" },
            { id: "same1-3", text: "IOT 컨테이너 사업에 대해서" },
            { id: "same1-4", text: "주간회의 특징 및 주요 말씀" },
            { id: "same1-5", text: "해운업계의 경쟁 구도" },
            { id: "same2-1", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "same2-2", text: "디지털화 근황" },
            { id: "same2-3", text: "IOT 컨테이너 사업에 대해서" },
            { id: "same2-4", text: "주간회의 특징 및 주요 말씀" },
            { id: "same2-5", text: "해운업계의 경쟁 구도" },
            { id: "same3-1", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "same3-2", text: "디지털화 근황" },
            { id: "same3-3", text: "IOT 컨테이너 사업에 대해서" },
            { id: "same3-4", text: "주간회의 특징 및 주요 말씀" },
            { id: "same3-5", text: "해운업계의 경쟁 구도" },
            { id: "same4-1", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "same4-2", text: "디지털화 근황" },
            { id: "same4-3", text: "IOT 컨테이너 사업에 대해서" },
            { id: "same4-4", text: "주간회의 특징 및 주요 말씀" },
            { id: "same4-5", text: "해운업계의 경쟁 구도" }
          ];
          queries = mixed20Queries3;
        } else if (testSet === 'same100') {
          for (let i = 1; i <= 100; i++) {
            queries.push({ id: `same100-${i}`, text: "디지털 전략" });
          }
        } else if (testSet === 'circulate5x20') {
          const baseQueries = [
            { id: "q1", text: "신입사원 인사 필수로 알아야 하는 것" },
            { id: "q2", text: "디지털화 근황" },
            { id: "q3", text: "IOT 컨테이너 사업에 대해서" },
            { id: "q4", text: "주간회의 특징 및 주요 말씀" },
            { id: "q5", text: "해운업계의 경쟁 구도" }
          ];
          for (let k = 1; k <= 40; k++) {
            baseQueries.forEach((q) => {
              queries.push({ id: `circulate${k}-${q.id}`, text: q.text });
            });
          }
        } else if (testSet === 'mixed100') {
          const mixedQueries = [
            { id: "mix-ask1", text: "타운사의 전략" },
            { id: "mix-ask2", text: "남성해운의 중국 시장 동향" },
            { id: "mix-ask3", text: "해운업계의 경쟁 구도" },
            { id: "mix-ask4", text: "디지털화의 최신 트렌드" },
            { id: "mix-ask5", text: "IOT 컨테이너 사업의 전망" },
            { id: "mix-ask6", text: "타운사의 시장 점유율 분석" },
            { id: "mix-ask7", text: "남성해운의 일본 시장 영업 전략" },
            { id: "mix-ask8", text: "해운업계의 글로벌 시장 동향" },
            { id: "mix-ask9", text: "디지털 전환의 성공 사례" },
            { id: "mix-ask10", text: "IOT 기술을 활용한 물류 혁신" },
            { id: "mix-ask11", text: "타운사의 경쟁 우위" },
            { id: "mix-ask12", text: "남성해운의 동남아 시장 발전 가능성" },
            { id: "mix-ask13", text: "해운업계의 기술 혁신 현황" },
            { id: "mix-ask14", text: "디지털 기술이 기업에 미치는 영향" },
            { id: "mix-ask15", text: "IOT와 빅데이터의 결합 사례" },
            { id: "mix-ask16", text: "타운사의 성장 동력" },
            { id: "mix-ask17", text: "남성해운의 미국 시장 진출 전략" },
            { id: "mix-ask18", text: "해운업계의 운임 변동 요인" },
            { id: "mix-ask19", text: "디지털화 도입의 비용 효율성" },
            { id: "mix-ask20", text: "IOT 기술 도입의 장단점" },
            { id: "mix-ask21", text: "타운사의 혁신 사례" },
            { id: "mix-ask22", text: "남성해운의 수익 구조 분석" },
            { id: "mix-ask23", text: "해운업계의 환경 규제 대응" },
            { id: "mix-ask24", text: "디지털 전환 전략 수립 방법" },
            { id: "mix-ask25", text: "IOT 컨테이너의 운영 효율성" },
            { id: "mix-ask26", text: "타운사의 고객 만족도" },
            { id: "mix-ask27", text: "남성해운의 비용 절감 전략" },
            { id: "mix-ask28", text: "해운업계의 디지털 전환" },
            { id: "mix-ask29", text: "디지털화와 빅데이터 활용" },
            { id: "mix-ask30", text: "IOT 기반 실시간 모니터링 시스템" },
            { id: "mix-ask31", text: "타운사의 재무 구조" },
            { id: "mix-ask32", text: "남성해운의 신규 서비스 도입" },
            { id: "mix-ask33", text: "해운업계의 물류 효율성 개선" },
            { id: "mix-ask34", text: "디지털화의 보안 이슈" },
            { id: "mix-ask35", text: "IOT와 인공지능의 결합 효과" },
            { id: "mix-ask36", text: "타운사의 리스크 관리" },
            { id: "mix-ask37", text: "남성해운의 고객 만족도 조사" },
            { id: "mix-ask38", text: "해운업계의 비용 구조" },
            { id: "mix-ask39", text: "디지털 트랜스포메이션의 장단점" },
            { id: "mix-ask40", text: "IOT 기술을 활용한 비용 절감" },
            { id: "mix-ask41", text: "타운사의 해외 진출 전략" },
            { id: "mix-ask42", text: "남성해운의 운임 변동 분석" },
            { id: "mix-ask43", text: "해운업계의 신규 시장 개척" },
            { id: "mix-ask44", text: "디지털화 추진을 위한 조직 문화" },
            { id: "mix-ask45", text: "IOT 컨테이너 사업의 경쟁력" },
            { id: "mix-ask46", text: "타운사의 신규 사업 계획" },
            { id: "mix-ask47", text: "남성해운의 미래 성장 전략" },
            { id: "mix-ask48", text: "해운업계의 고객 서비스 혁신" },
            { id: "mix-ask49", text: "디지털 전환과 고객 경험 혁신" },
            { id: "mix-ask50", text: "IOT 기술 도입을 위한 투자 전략" },
            { id: "mix-ask51", text: "타운사의 브랜드 가치" },
            { id: "mix-ask52", text: "남성해운의 경쟁사 비교" },
            { id: "mix-ask53", text: "해운업계의 글로벌 네트워크" },
            { id: "mix-ask54", text: "디지털화와 인공지능의 결합" },
            { id: "mix-ask55", text: "IOT와 클라우드 컴퓨팅의 연계" },
            { id: "mix-ask56", text: "타운사의 공급망 관리" },
            { id: "mix-ask57", text: "남성해운의 글로벌 네트워크" },
            { id: "mix-ask58", text: "해운업계의 재무 안정성" },
            { id: "mix-ask59", text: "디지털 전환의 글로벌 사례" },
            { id: "mix-ask60", text: "IOT 기반 물류 자동화 사례" },
            { id: "mix-ask61", text: "타운사의 인재 육성 전략" },
            { id: "mix-ask62", text: "남성해운의 혁신 기술 도입" },
            { id: "mix-ask63", text: "해운업계의 기술 투자" },
            { id: "mix-ask64", text: "디지털화 추진 시 장애 요인" },
            { id: "mix-ask65", text: "IOT 기술의 보안 이슈" },
            { id: "mix-ask66", text: "타운사의 사회적 책임 활동" },
            { id: "mix-ask67", text: "남성해운의 운영 효율성" },
            { id: "mix-ask68", text: "해운업계의 공급망 관리" },
            { id: "mix-ask69", text: "디지털화에 따른 비용 절감 효과" },
            { id: "mix-ask70", text: "IOT 컨테이너 사업의 글로벌 동향" },
            { id: "mix-ask71", text: "타운사의 기술 혁신" },
            { id: "mix-ask72", text: "남성해운의 재무 건전성" },
            { id: "mix-ask73", text: "해운업계의 미래 전망" },
            { id: "mix-ask74", text: "디지털 트랜스포메이션의 미래 전망" },
            { id: "mix-ask75", text: "IOT와 데이터 분석의 시너지 효과" },
            { id: "mix-ask76", text: "타운사의 마케팅 전략" },
            { id: "mix-ask77", text: "남성해운의 리스크 관리 전략" },
            { id: "mix-ask78", text: "해운업계의 혁신 사례" },
            { id: "mix-ask79", text: "디지털화 전략 수립 시 고려사항" },
            { id: "mix-ask80", text: "IOT 기술 도입 시 장애 요인" },
            { id: "mix-ask81", text: "타운사의 고객 서비스 개선" },
            { id: "mix-ask82", text: "남성해운의 신규 투자 계획" },
            { id: "mix-ask83", text: "해운업계의 위험 요인" },
            { id: "mix-ask84", text: "디지털 전환이 기업 경쟁력에 미치는 영향" },
            { id: "mix-ask85", text: "IOT 컨테이너의 미래 전략" },
            { id: "mix-ask86", text: "타운사의 경쟁사 비교" },
            { id: "mix-ask87", text: "남성해운의 시장 점유율 변화" },
            { id: "mix-ask88", text: "해운업계의 인재 육성" },
            { id: "mix-ask89", text: "디지털화와 클라우드 컴퓨팅" },
            { id: "mix-ask90", text: "IOT 기술을 활용한 혁신 사례" },
            { id: "mix-ask91", text: "타운사의 시장 성장 전망" },
            { id: "mix-ask92", text: "남성해운의 고객 서비스 전략" },
            { id: "mix-ask93", text: "해운업계의 시장 성장 동력" },
            { id: "mix-ask94", text: "디지털 전환의 성공 요인" },
            { id: "mix-ask95", text: "IOT 기반 스마트 물류 솔루션" },
            { id: "mix-ask96", text: "타운사의 미래 비전" },
            { id: "mix-ask97", text: "남성해운의 미래 비전" },
            { id: "mix-ask98", text: "해운업계의 신기술 도입 현황" },
            { id: "mix-ask99", text: "디지털 트랜스포메이션이 해운업계에 미치는 영향" },
            { id: "mix-ask100", text: "IOT 기술이 해운업계에 미치는 영향" }
          ];
          queries = mixedQueries; // Use the mixed set
        }
        return queries;
      }
    
      /************************************************************
       * (For Continuous Test) Non-streaming version: normal POST request
       ************************************************************/
      async function runNonStreamingQuery(qObj) {
        const sendTime = new Date();
        const startTs = Date.now();
        try {
          const resp = await fetch('/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ qry_contents: qObj.text })
          });
          await resp.json();
        } catch (e) {
          console.error("Non-stream error:", e);
        }
        const endTime = new Date();
        const duration = Date.now() - startTs;
        return {
          id: qObj.id,
          query: qObj.text,
          startTime: formatTime(sendTime),
          endTime: formatTime(endTime),
          duration: duration
        };
      }
    
      /************************************************************
       * (For Continuous Test) Streaming version: SSE approach (GET-based)
       ************************************************************/
      function runStreamingQuery(qObj) {
        return new Promise((resolve, reject) => {
          const sendTime = new Date();
          const startTs = Date.now();
          const sseUrl = '/query_stream?input=' + encodeURIComponent(qObj.text);
          const es = new EventSource(sseUrl);
          es.onmessage = (evt) => {
            const trimmed = evt.data.trim();
            if (trimmed.includes("[[STREAM_DONE]]")) {
              es.close();
              const endTime = new Date();
              const duration = Date.now() - startTs;
              resolve({
                id: qObj.id,
                query: qObj.text,
                startTime: formatTime(sendTime),
                endTime: formatTime(endTime),
                duration: duration
              });
            }
          };
          es.onerror = (err) => {
            console.error("Stream error on", qObj.id, err);
            es.close();
            const endTime = new Date();
            const duration = Date.now() - startTs;
            resolve({
              id: qObj.id,
              query: qObj.text,
              startTime: formatTime(sendTime),
              endTime: formatTime(endTime),
              duration: duration
            });
          };
        });
      }
    </script>
  </body>
</html>
